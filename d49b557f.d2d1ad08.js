(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{101:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return s}));var a=n(2),r=n(6),o=(n(0),n(115)),i={id:"configure_keymap",title:"Configuring keymap.h.cpp",slug:"/configure_keymap"},c={unversionedId:"configure_keymap",id:"configure_keymap",isDocsHomePage:!1,title:"Configuring keymap.h.cpp",description:"Configuring your keyboard - Part 3: Keymap Definition",source:"@site/docs/configuring_firmware_3.md",slug:"/configure_keymap",permalink:"/docs/configure_keymap",editUrl:"https://github.com/jpconstantineau/BlueMicro_BLE/tree/documentation-docusaurus/documentation/docs/configuring_firmware_3.md",version:"current",sidebar:"someSidebar",previous:{title:"Configuring keyboard_config.h",permalink:"/docs/configure_keyboard"},next:{title:"Configuring your own keymap",permalink:"/docs/keymaps"}},l=[{value:"Configuring your keyboard - Part 3: Keymap Definition",id:"configuring-your-keyboard---part-3-keymap-definition",children:[{value:"The default layer",id:"the-default-layer",children:[]},{value:"Further layers",id:"further-layers",children:[]},{value:"Rotary Encoder Definition",id:"rotary-encoder-definition",children:[]},{value:"OLED Definition",id:"oled-definition",children:[]},{value:"Speaker/Buzzer/Audio Definition",id:"speakerbuzzeraudio-definition",children:[]},{value:"Keyboard Modes and Persistent User States",id:"keyboard-modes-and-persistent-user-states",children:[]}]}],d={rightToc:l};function s(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},d,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"configuring-your-keyboard---part-3-keymap-definition"},"Configuring your keyboard - Part 3: Keymap Definition"),Object(o.b)("h3",{id:"the-default-layer"},"The default layer"),Object(o.b)("p",null,'The default layer is the layer which you will most often use. Generally this is the "QWERTY" Layer.\nFor example for the gherkin 3x10:'),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),"std::array<std::array<Key, MATRIX_COLS>, MATRIX_ROWS> matrix =\n    KEYMAP2ARRAY(KEYMAP(\n        KC_Q,    KC_W,    KC_E,    KC_R,    KC_T,    KC_Y,    KC_U,    KC_I,    KC_O,    KC_P,\n        KC_A,    KC_S,    KC_D,    KC_F,    KC_G,    KC_H,    KC_J,    KC_K,    KC_L,    KC_ESC,\n        KC_Z,    KC_X,    KC_C,    KC_V,    KC_SPC,  KC_BKSPC,KC_B,    KC_N,    KC_M,    KC_NO \n        ));\n        \n")),Object(o.b)("p",null,"Notice the 2 macros being used: ",Object(o.b)("inlineCode",{parentName:"p"},"KEYMAP2ARRAY")," and ",Object(o.b)("inlineCode",{parentName:"p"},"KEYMAP"),". Since the ",Object(o.b)("inlineCode",{parentName:"p"},"matrix")," variable is a c++ array, we need to convert the output of the ",Object(o.b)("inlineCode",{parentName:"p"},"KEYMAP")," macro from a C array to a c ++ array. "),Object(o.b)("h3",{id:"further-layers"},"Further layers"),Object(o.b)("p",null,"For additional layers, you will need to programatically add the layers and the keycodes.  This is done in the function ",Object(o.b)("inlineCode",{parentName:"p"},"setupKeymap()"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),"void setupKeymap() {\n\n    uint32_t layer1[MATRIX_ROWS][MATRIX_COLS] =\n        KEYMAP(\n    KC_NO,    KC_NO,    KC_NO,    KC_NO,    KC_NO,     KC_NO,    KC_NO,    KC_NO,    KC_NO,    KC_NO,\n    KC_NO,    KC_NO,    KC_NO,    KC_NO,    KC_NO,     KC_NO,    KC_NO,    KC_NO,    KC_NO,    KC_NO,\n    KC_Z,     KC_X,     KC_C,     KC_V,     KC_SPC,    KC_BSPC,  KC_B,     KC_N,     KC_M,     KC_ENT );\n\n    ADDLAYER(_L1, Method::PRESS , layer1);\n\n}\n\n")),Object(o.b)("p",null,"Notice that in the ",Object(o.b)("inlineCode",{parentName:"p"},"setupKeymap()")," function, we use c arrays that only need the ",Object(o.b)("inlineCode",{parentName:"p"},"KEYMAP2ARRAY")," macro to help you with your keymap."),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"ADDLAYER")," macro simplifies the process of adding your layer and has the following arguments:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"LAYER NUMBER"),": The first argument is the layer number.  Unlike the layer keycode, this is a simple number from 0 to 6 (up to 15 may be supported; depending on memory availability and matrix size)."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"ACTIVATION METHOD"),": Generally, you will use the ",Object(o.b)("inlineCode",{parentName:"li"},"Method::PRESS")," method. Other methods are ",Object(o.b)("inlineCode",{parentName:"li"},"Method::MT_TAP"),", ",Object(o.b)("inlineCode",{parentName:"li"},"Method::MT_HOLD"),", ",Object(o.b)("inlineCode",{parentName:"li"},"Method::DT_TAP")," and ",Object(o.b)("inlineCode",{parentName:"li"},"Method::DT_DOUBLETAP"),'. If a key keys triggered using multiple methods, all methods will "fire" and send a keycode.  As such, it\'s useful to use the ',Object(o.b)("inlineCode",{parentName:"li"},"KC_NO")," keycode to avoid sending anything for a specific activation."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("strong",{parentName:"li"},"KEYMAP ARRAY"),": This is the C array to load.")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"ADDLAYER")," macro wraps the Key::addActivation with a loop for all rows and columns of the key matrix. "),Object(o.b)("p",null,"Note that when using ",Object(o.b)("inlineCode",{parentName:"p"},"KC_NO")," as the keycode within a layer, the firmware will automatically bypass this keycode for this specific key and it won't be added to its mapping.  As such, having lots of ",Object(o.b)("inlineCode",{parentName:"p"},"KC_NO")," keycodes in a layer won't affect the performance of the keyboard."),Object(o.b)("h3",{id:"rotary-encoder-definition"},"Rotary Encoder Definition"),Object(o.b)("p",null,"You can refer to the configuration of the solfle keyboard - default configuration for a working example."),Object(o.b)("p",null," This configuration uses the hardware QDEC peripheral (Quadrature Decoder) that's part of the nRF52 SoC and uses callbacks to handle rotation.  The Adafruit library also supports software interrupts for 4 encoders but this has not been fully tested.  This limit on the number of encoders supported using software interrupts can be modified in the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/jpconstantineau/Adafruit_nRF52_Arduino/blob/master/libraries/RotaryEncoder/SwRotaryEncoder.cpp"}),"library"),".  Refer to the examples in the library if you want to implement multiple encoders."),Object(o.b)("p",null,"You will need to add a few things to your keymap.h file."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),'#include "KeyScanner.h"  // include at the top with the other includes\nextern DynamicState keyboardstate;\nvoid encoder_callback(int step); // add right after void setupKeymap();\n\n')),Object(o.b)("p",null,"You will also need to add a few things to your keymap.cpp file.  For example, you will need to add the following 3 lines in the ",Object(o.b)("inlineCode",{parentName:"p"},"setupKeymap()")," function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),"// Code below makes sure that the encoder gets configured.\n\n  RotaryEncoder.begin(ENCODER_PAD_A, ENCODER_PAD_B);    // Initialize Encoder\n  RotaryEncoder.setCallback(encoder_callback);    // Set callback\n  RotaryEncoder.start();    // Start encoder\n\n")),Object(o.b)("p",null,"You will need to add the  ",Object(o.b)("inlineCode",{parentName:"p"},"encoder_callback()")," function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),"void encoder_callback(int step)\n{\n  uint8_t layer = keyboardstate.layer;\n  if ( step > 0 )\n  {\n      switch(layer)\n      {\n          case _L0: KeyScanner::add_to_encoderKeys(KC_AUDIO_VOL_UP); break;\n          case _L1: KeyScanner::add_to_encoderKeys(KC_RIGHT); break;\n          case _L2: KeyScanner::add_to_encoderKeys(LSFT(KC_RIGHT)); break;\n          default: ;\n      }\n  }else\n  {\n      switch(layer)\n      {\n          case _L0: KeyScanner::add_to_encoderKeys(KC_AUDIO_VOL_DOWN); break;\n          case _L1: KeyScanner::add_to_encoderKeys(KC_LEFT);break;\n          case _L2: KeyScanner::add_to_encoderKeys(LSFT(KC_LEFT));break;\n          default: ;\n      }\n  }  \n}\n\n")),Object(o.b)("p",null,"If you rotate in one direction and the keycodes are for the other direction, simply change the ",Object(o.b)("inlineCode",{parentName:"p"},"if ( step > 0 )")," statement to ",Object(o.b)("inlineCode",{parentName:"p"},"if ( step < 0 )")," or swap the keycodes around."),Object(o.b)("h3",{id:"oled-definition"},"OLED Definition"),Object(o.b)("p",null,"The default screens can be overriden by assigning a new callback. "),Object(o.b)("p",null,"You will need to add a few things to your keymap.h file."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),'#include "BlueMicro_display.h"\n\n#ifdef BLUEMICRO_CONFIGURED_DISPLAY\nextern BlueMicro_Display OLED;        // needed to assign the update display callback\nextern DISPLAY_U8G2_CONSTRUCTOR u8g2; // needed to call the display functions\n#endif\n\nvoid updateDisplay(PersistentState* cfg, DynamicState* stat);\n\n')),Object(o.b)("p",null,"You will also need to add a few things to your keymap.cpp file.  For example, you will need to add the following 3 lines in the ",Object(o.b)("inlineCode",{parentName:"p"},"setupKeymap()")," function:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),"\n    #ifdef BLUEMICRO_CONFIGURED_DISPLAY\n    OLED.setStatusDisplayCallback(updateDisplay);\n    #endif\n\n")),Object(o.b)("p",null,"You will then need to define the ",Object(o.b)("inlineCode",{parentName:"p"},"updateDisplay()")," function with your own requirements.  The following is an example that provides a battery icon, the computer or half it is connected to and the currently active layer. "),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),'void updateDisplay(PersistentState* cfg, DynamicState* stat)\n{\n    #ifdef BLUEMICRO_CONFIGURED_DISPLAY\n    u8g2.setFontMode(1);    // Transparent\n    u8g2.setFontDirection(0);\n    battery(22,19,stat->vbat_per);\n    printline(0,28,stat->peer_name_prph);\n\n    char buffer [50];\n    u8g2.setFont(u8g2_font_helvB12_tf); // choose a suitable font\n    switch(stat->layer)\n    {\n        case _QWERTY:     u8g2.drawStr(0,128,""); break;\n        case _LOWER:      u8g2.drawStr(0,128,"L");break;\n        case _RAISE:     u8g2.drawStr(0,128,"R");break;\n        case _ADJUST:     u8g2.drawStr(0,128,"A");break;\n        case _EXTRAL:     u8g2.drawStr(0,128,"EL");break;\n        case _EXTRAR:     u8g2.drawStr(0,128,"ER");break; \n        case _MACROL:     u8g2.drawStr(0,128,"ML");break;\n        case _MACROR:     u8g2.drawStr(0,128,"MR");break; \n        case _MACRO:     u8g2.drawStr(0,128,"M");break;    \n    }\n    #endif\n}\n')),Object(o.b)("h3",{id:"speakerbuzzeraudio-definition"},"Speaker/Buzzer/Audio Definition"),Object(o.b)("p",null,"If you want to add additional audio feedback to your macros or user functions, you will need to add a few lines to your keymap.h file:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),'#include "BlueMicro_tone.h"\nextern BlueMicro_tone speaker; \n')),Object(o.b)("p",null,"Refer to the Luddite, default keymap for an example how to add music to your macros."),Object(o.b)("h3",{id:"keyboard-modes-and-persistent-user-states"},"Keyboard Modes and Persistent User States"),Object(o.b)("p",null,"When booting up, the keyboard can use pre-saved configuration information to be able to adjust the keymap according to the mode the user has previously saved.  "),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"PersistentState")," structure that's saved in flash has the following fields available for the user to use to change the behavior of the keyboard when booting up:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c++"}),"        uint8_t    mode;\n        uint8_t    user1;  \n        uint8_t    user2; \n")),Object(o.b)("p",null,"Default values for all 3 fields are 0."),Object(o.b)("p",null,"See the ",Object(o.b)("inlineCode",{parentName:"p"},"4x4Backpack Modes")," keymap to see an example of how dynamic the selection of the keymap to be loaded on startup is performed and how saving the mode is done using Macro functionality."),Object(o.b)("p",null,"Since the ",Object(o.b)("inlineCode",{parentName:"p"},"setupKeymap()")," function also sets up the rotary encoder callback, it's possible to change the functionality of the rotary encoder depending on the mode (or other user variables) selected."))}s.isMDXComponent=!0},115:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return y}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=r.a.createContext({}),s=function(e){var t=r.a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},u=function(e){var t=s(e.components);return r.a.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=s(n),b=a,y=u["".concat(i,".").concat(b)]||u[b]||p[b]||o;return n?r.a.createElement(y,c(c({ref:t},d),{},{components:n})):r.a.createElement(y,c({ref:t},d))}));function y(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=b;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var d=2;d<o;d++)i[d]=n[d];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);